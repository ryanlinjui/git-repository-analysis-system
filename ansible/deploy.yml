---
- name: Deploy Git Repository Analysis System
  hosts: production
  become: yes
  vars:
    app_dir: "{{ deploy_directory }}"
    docker_image: "{{ docker_image }}"

  tasks:
    - name: Check if Docker is already installed
      command: docker --version
      register: docker_check
      ignore_errors: yes
      changed_when: false

    - name: Install prerequisites
      apt:
        name:
          - ca-certificates
          - curl
        state: present
        update_cache: yes
      when: docker_check.rc != 0

    - name: Add Docker GPG key
      shell: |
        install -m 0755 -d /etc/apt/keyrings
        curl -fsSL https://download.docker.com/linux/debian/gpg -o /etc/apt/keyrings/docker.asc
        chmod a+r /etc/apt/keyrings/docker.asc
      when: docker_check.rc != 0

    - name: Add Docker repository
      shell: |
        echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/debian $(. /etc/os-release && echo "$VERSION_CODENAME") stable" | tee /etc/apt/sources.list.d/docker.list > /dev/null
      when: docker_check.rc != 0

    - name: Update apt cache after adding Docker repo
      apt:
        update_cache: yes
      when: docker_check.rc != 0

    - name: Install Docker packages
      apt:
        name:
          - docker-ce
          - docker-ce-cli
          - containerd.io
          - docker-buildx-plugin
          - docker-compose-plugin
        state: present
      when: docker_check.rc != 0

    - name: Ensure Docker service is running
      systemd:
        name: docker
        state: started
        enabled: yes

    - name: Create application directory
      file:
        path: "{{ app_dir }}"
        state: directory
        mode: '0755'

    - name: Check if .env exists on VM
      stat:
        path: "{{ app_dir }}/.env"
      register: env_file

    - name: Fail if .env not found
      fail:
        msg: "Please upload .env file to {{ app_dir }}/.env on VM before deployment"
      when: not env_file.stat.exists

    - name: Check if service account file exists on VM
      stat:
        path: "{{ app_dir }}/service-account-file.json"
      register: sa_file

    - name: Fail if service account file not found
      fail:
        msg: "Please upload service-account-file.json to {{ app_dir }}/service-account-file.json on VM before deployment"
      when: not sa_file.stat.exists

    - name: Copy docker-compose.yml
      copy:
        src: compose.yml
        dest: "{{ app_dir }}/docker-compose.yml"
        mode: '0644'

    - name: Copy config directory
      copy:
        src: config/
        dest: "{{ app_dir }}/config/"
        mode: '0644'

    - name: Log in to GitHub Container Registry
      command: >
        docker login ghcr.io -u {{ lookup('env', 'GITHUB_ACTOR') }} 
        -p {{ lookup('env', 'GITHUB_TOKEN') }}
      environment:
        GITHUB_ACTOR: "{{ lookup('env', 'GITHUB_ACTOR') }}"
        GITHUB_TOKEN: "{{ lookup('env', 'GITHUB_TOKEN') }}"
      no_log: true

    - name: Pull latest Docker image
      docker_image:
        name: "{{ docker_image }}"
        source: pull
        force_source: yes

    - name: Stop existing containers
      command: docker compose down
      args:
        chdir: "{{ app_dir }}"
      ignore_errors: yes

    - name: Start application with docker-compose
      command: docker compose up -d --force-recreate
      args:
        chdir: "{{ app_dir }}"
      environment:
        COMPOSE_PROJECT_NAME: git-analysis

    - name: Clean up old Docker images
      command: docker image prune -af
      ignore_errors: yes

    - name: Wait for all containers to be running
      shell: |
        EXPECTED=$(docker compose config --services | wc -l)
        RUNNING=$(docker compose ps --status running --format json 2>/dev/null | jq -s 'length')
        [ "$RUNNING" -eq "$EXPECTED" ]
      args:
        chdir: "{{ app_dir }}"
      register: containers_running
      until: containers_running.rc == 0
      retries: 24
      delay: 5

    - name: Check container health status
      shell: |
        docker compose ps --format json | jq -r '.[] | select(.Health != "" and .Health != "healthy") | .Name' | wc -l
      args:
        chdir: "{{ app_dir }}"
      register: unhealthy_count
      failed_when: false

    - name: Get app container port mapping
      shell: docker compose ps app --format json | jq -r '.[0].Publishers[0].PublishedPort // "3000"'
      args:
        chdir: "{{ app_dir }}"
      register: app_published_port
      changed_when: false
      failed_when: false

    - name: Test application HTTP endpoint from host
      uri:
        url: "http://localhost:{{ app_published_port.stdout }}"
        method: GET
        status_code: 200
        timeout: 10
      register: app_health
      until: app_health.status == 200
      retries: 12
      delay: 5
      when: app_published_port.stdout != ''
      failed_when: false

    - name: Test application via docker network (fallback)
      shell: docker run --rm --network git-analysis_default curlimages/curl:latest curl -f -s http://app:3000 > /dev/null
      register: app_network_health
      until: app_network_health.rc == 0
      retries: 6
      delay: 5
      when: app_health is failed or app_published_port.stdout == ''
      ignore_errors: yes

    - name: Verify Grafana is accessible
      uri:
        url: "http://localhost:3001"
        method: GET
        status_code: 200,302
        timeout: 10
      register: grafana_health
      until: grafana_health.status in [200, 302]
      retries: 6
      delay: 5
      ignore_errors: yes

    - name: Check application status
      command: docker compose ps
      args:
        chdir: "{{ app_dir }}"
      register: docker_ps

    - name: Display application status
      debug:
        var: docker_ps.stdout_lines

    - name: Display health summary
      debug:
        msg: 
          - "All containers running: {{ containers_running.rc == 0 }}"
          - "Unhealthy containers: {{ unhealthy_count.stdout }}"
          - "App port detected: {{ app_published_port.stdout | default('N/A') }}"
          - "App HTTP responding: {{ app_health.status == 200 if app_health is defined and app_health.status is defined else (app_network_health.rc == 0 if app_network_health is defined else 'N/A') }}"
          - "Grafana responding: {{ grafana_health.status in [200, 302] if grafana_health is defined and grafana_health.status is defined else 'N/A' }}"